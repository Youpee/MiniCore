# core/inc/interfaces/button_handler.h

## Общее назначение
Файл `button_handler.h` определяет интерфейс для объектов, которые могут обрабатывать кнопки. Он предоставляет возможности для управления позициями кнопок и обработкой событий нажатий. Данный интерфейс позволяет добавлять, удалять и изменять контекст кнопок, а также взаимодействовать с ними через заданные координаты.

## Основные компоненты
### Функции
- ``Button **buttons_init(int length)``
  - Инициализирует массив кнопок, если используется динамическое выделение памяти.
  - Используется при создании обработчика кнопок с заданным количеством кнопок.

- ``void add_button(ButtonHandler *button_handler, Button *button)``
  - Добавляет кнопку в обработчик кнопок.
  - Принимает указатель на `ButtonHandler` и кнопку, которую необходимо добавить.

- ``void remove_button(ButtonHandler *button_handler, int index)``
  - Удаляет кнопку из обработчика по указанному индексу.
  - Принимает указатель на `ButtonHandler` и индекс кнопки для удаления.

- ``void set_button_context(ButtonHandler *button_handler, int index, void *context)``
  - Устанавливает контекст для кнопки по указанному индексу.
  - Контекст может быть использован для передачи дополнительных данных в обработчик событий.

- ``Button *get_button(ButtonHandler *button_handler, int index)``
  - Получает кнопку из обработчика по указанному индексу.
  - Используется для доступа к конкретной кнопке в массиве.

- ``bool is_button(void *object, Coords coords)``
  - Проверяет, является ли объект кнопкой по заданным координатам.
  - Возвращает true, если объект соответствует кнопке.

- ``Button *get_button_by_coords(void *object, Coords coords)``
  - Получает кнопку на основе заданных координат.
  - Используется для определения кнопки, с которой взаимодействует пользователь.

- ``void handle_button(void *object, Coords coords)``
  - Обрабатывает нажатие кнопки, если она находится по заданным координатам.
  - Позволяет инициировать соответствующие действия при взаимодействии с кнопкой.

### Переменные
- `typedef struct Button`
  - Структура, представляющая кнопку с её координатами, контекстом и указателем на функцию-обработчик нажатий.

- `typedef struct ButtonHandler`
  - Структура, представляющая обработчик кнопок, который может содержать статический или динамический массив кнопок и их количество.

### Макросы
- ``#define BUTTON_HANDLER_SIZE 1``
  - Определяет размер массива кнопок в обработчике (по умолчанию равен 1).

- ``static inline ButtonHandler *BUTTON_HANDLER(const void *object)``
  - Получает указатель на `ButtonHandler` для данного объекта.

- ``static inline bool HAVE_BUTTONS(const void *object)``
  - Проверяет, есть ли у объекта кнопки.

- ``static inline void SET_BUTTON_CONTEXT(void *object, int index, void *context)``
  - Устанавливает контекст для кнопки по указанному индексу через макрос.

## Логика работы
Файл определяет структуру `ButtonHandler`, которая хранит массив кнопок и их количество. Основные функции позволяют добавлять и удалять кнопки, устанавливать контекст и обрабатывать нажатия. При использовании динамического выделения памяти, функция `buttons_init` отвечает за инициализацию массива. Взаимодействие с другими модулями происходит через интерфейсы объектов, которые предоставляют доступ к кнопкам через макросы, такие как `BUTTON_HANDLER` и `HAVE_BUTTONS`. Обработчик кнопок интегрируется в общую архитектуру через указатели на функции, что позволяет гибко обрабатывать события нажатия.

## Простой пример использования
- Пример:
  ```c
  ButtonHandler my_handler;
  Button my_button;
  add_button(&my_handler, &my_button);
  ```

- Объяснение примера:
  В данном примере создается обработчик кнопок `my_handler` и кнопка `my_button`. Функция `add_button` добавляет кнопку в обработчик, что позволяет системе отслеживать нажатия этой кнопки. Использование этого интерфейса упрощает управление кнопками в приложении.

# core/inc/interfaces/card_handler.h

## Общее назначение
Файл `card_handler.h` содержит интерфейс для объектов, которые могут работать с картами. Он предоставляет полные возможности манипуляции картами, включая выбор, размещение и получение карт. Данный интерфейс также включает функции для проверки возможностей работы с картами.

## Основные компоненты

### Функции
- ``const CardHandler *CARD_HANDLER(const void *object)``
  - Возвращает указатель на интерфейс `CardHandler`, связанный с заданным объектом.
- ``bool IS_CARD_HANDLER(const void *object)``
  - Проверяет, поддерживает ли объект интерфейс `CardHandler`.
- ``bool CAN_GIVE_CARDS(const void *object)``
  - Определяет, может ли объект раздавать карты.
- ``bool CAN_TAKE_CARDS(const void *object)``
  - Определяет, может ли объект забирать карты.
- ``bool CAN_PLACE_CARDS(const void *object, const Coords coords, const Container *container)``
  - Проверяет, может ли объект размещать карты в указанной координате и контейнере.
- ``bool IS_SAME_CARD(const void *object, const Coords coords, const Card *card)``
  - Проверяет, является ли карта в указанных координатах той же самой, что и переданная.
- ``void SELECT_CARDS(void *object, const Coords coords, Container *container)``
  - Вызывает функцию выбора карт у объекта.
- ``void GET_CARDS(void *object, Container *container)``
  - Получает карты у объекта.
- ``void PLACE_CARDS(void *object, const Coords coords, Container *container)``
  - Размещает карты в указанных координатах и контейнере.

### Переменные
- `bool can_give_cards` - Указывает, может ли объект раздавать карты.
- `bool can_take_cards` - Указывает, может ли объект забирать карты.

### Макросы
Не предусмотрены.

## Логика работы
Интерфейс `CardHandler` предоставляет функции для взаимодействия с картами, включая выбор, размещение и получение карт. Эти функции используются в зависимости от возможностей объекта, которые проверяются с помощью различных вспомогательных функций. Связь с другими модулями осуществляется через макросы, предоставляющие доступ к интерфейсу и его методам.

## Простой пример использования
```c
Container *container;
Coords coords;

// Проверка возможности раздачи карт
if (CAN_GIVE_CARDS(object)) {
    SELECT_CARDS(object, coords, container); // Выбор карт из объекта
}

// Размещение карт
if (CAN_PLACE_CARDS(object, coords, container)) {
    PLACE_CARDS(object, coords, container); // Размещение карт в заданной области
}
```
В данном примере проверяется, может ли объект раздавать карты, после чего происходит выбор и размещение карт в контейнере. Это демонстрирует основные функции интерфейса `CardHandler` и его использование в манипуляции картами.

# core/inc/interfaces/core_dependent.h

## Общее назначение
Файл `core_dependent.h` определяет интерфейс `CoreDependent`, предназначенный для объектов, которые зависят от ядра. Он предоставляет функции для управления слоями, перемещения и завершения работы объектов, а также для получения экрана, связанного с ядром. Этот интерфейс позволяет объектам взаимодействовать с основными функциональными возможностями системы.

## Основные компоненты
### Функции
- ```const CoreDependent *CORE_DEPENDENT_HANDLER(const void *object)```
  - Возвращает указатель на структуру `CoreDependent`, связанную с данным объектом.
  
- ```bool IS_CORE_DEPENDENT(const void *object)```
  - Проверяет, является ли объект зависимым от ядра.

- ```Core *GET_CORE(const void *object)```
  - Возвращает указатель на объект ядра, связанный с данным объектом, или NULL, если объект не является зависимым от ядра.

- ```Screen *CORE_GET_SCREEN(const void *object)```
  - Получает экран, связанный с ядром, для данного объекта.

- ```void CORE_CHANGE_LAYER(const void *object, int layer)```
  - Изменяет слой для объекта, если он зависит от ядра.

- ```void CORE_ACTION(const void *object)```
  - Выполняет действие для зависимого от ядра объекта.

- ```void CORE_GLOBAL_MOVE(const void *object, Coords move)```
  - Выполняет глобальное перемещение для зависимого от ядра объекта.

- ```void CORE_LOCAL_MOVE(const void *object, Coords move)```
  - Выполняет локальное перемещение для зависимого от ядра объекта.

- ```void CORE_SHUTDOWN(const void *object)```
  - Завершает работу зависимого от ядра объекта.

### Переменные
Нет объявленных переменных в этом файле.

### Макросы
Нет макросов, кроме функций, упомянутых выше.

## Логика работы
Интерфейс `CoreDependent` позволяет объектам, которые используют его, выполнять различные действия, зависящие от состояния ядра. Взаимодействие происходит через функции, которые обеспечивают доступ к методам и полям структуры `Core`. Проверка зависимостей осуществляется через макросы, которые дают возможность убедиться в наличии необходимых возможностей для выполнения определённых операций. Это помогает поддерживать раздельность и модульность в архитектуре проекта.

## Простой пример использования
- Пример: 
```c
CORE_ACTION(my_object);
```
- Объяснение примера: 
Данный пример вызывает действие для объекта `my_object`, если он зависит от ядра. Это позволяет выполнить предопределённую логику, связанную с состоянием ядра, используя интерфейс `CoreDependent`.

# core/inc/interfaces/drawable.h

## Общее назначение
Файл `drawable.h` определяет интерфейс для объектов, которые могут быть нарисованы на экране. Интерфейс включает функциональность для активации и деактивации объектов, а также метод для их отображения на экране. Реализации этого интерфейса должны предоставлять собственный метод рисования.

## Основные компоненты
### Функции
- ```Drawable *DRAW_HANDLER(const void *object);```
  Возвращает указатель на структуру `Drawable` для данного объекта. Используется для доступа к методам интерфейса.
  
- ```bool IS_DRAWABLE(const void *object);```
  Проверяет, поддерживает ли объект интерфейс `Drawable`. Возвращает `true`, если объект может быть нарисован.
  
- ```void DRAW(const void *object, Screen *screen, Cursor *cursor);```
  Вызывает метод `print` для рисования объекта на заданном экране с указателем курсора.
  
- ```bool IS_ACTIVE_DRAWABLE(const void *object);```
  Проверяет, активен ли объект, реализующий интерфейс `Drawable`. Возвращает `true`, если объект активен.
  
- ```void SET_DRAWABLE_ACTIVE(void *object, bool active);```
  Устанавливает состояние активности объекта, реализующего интерфейс `Drawable`.

### Переменные
- `bool is_active;`
  Указывает, активен ли объект, реализующий интерфейс `Drawable`.

### Макросы
Не содержится.

## Логика работы
Интерфейс `Drawable` служит для реализации объектов, которые могут быть изображены на экране. Основные операции, такие как проверка активности и выполнение метода рисования, выполняются через функции-обертки. Они позволяют обрабатывать объекты, не зная их конкретных реализаций. Методы, которые должны быть реализованы, включают `print`, отвечающий за отображение объекта, что делает интерфейс универсальным для различных графических объектов.

## Простой пример использования
- Пример:
```c
if (IS_ACTIVE_DRAWABLE(object)) {
    DRAW(object, screen, cursor);
}
```

- Объяснение примера:
В этом примере проверяется, является ли объект активным и поддерживает ли интерфейс `Drawable`. Если это так, вызывается функция `DRAW`, которая рисует объект на заданном экране с использованием указателя курсора. Это позволяет эффективно управлять рисованием объектов, только если они находятся в активном состоянии.

# core/inc/interfaces/dynamic.h

## Общее назначение
Файл `dynamic.h` содержит интерфейс `Dynamic`, который предназначен для объектов, способных на динамическое распределение памяти. Он предоставляет функциональность для освобождения ресурсов, ассоциированных с динамическими объектами, что позволяет предотвратить утечки памяти.

## Основные компоненты
### Функции
- ```void (*free)(void *self);```
  - Метод освобождения ресурсов, выделенных для объекта.
  - Особенности использования: вызов этого метода должен происходить после завершения работы с объектом, чтобы избежать утечек памяти.

### Макросы
- ```static inline const Dynamic *DYNAMIC_HANDLER(const void *object);```
  - Возвращает указатель на интерфейс `Dynamic` для данного объекта.
- ```static inline bool IS_DYNAMIC(const void *object);```
  - Проверяет, поддерживает ли объект динамическое выделение памяти.
- ```static inline void FREE(void *object);```
  - Освобождает память, связанную с объектом, вызывая метод `free`.

## Логика работы
Интерфейс `Dynamic` позволяет объектам, которые используют динамическое распределение памяти, управлять своим состоянием и освобождать выделенные ресурсы. Через макросы `DYNAMIC_HANDLER` и `IS_DYNAMIC` можно легко взаимодействовать с объектами и проверять их возможность освобождения памяти. Метод `free` вызывается для безопасного освобождения ресурсов, что является критически важным для управления памятью в больших проектах. 

## Простой пример использования
- Пример: 
  ```c
  FREE(my_dynamic_object);
  ```
- Объяснение примера: В данном примере вызывается функция `FREE`, которая, в свою очередь, вызывает метод `free` для объекта `my_dynamic_object`. Это позволяет корректно освободить память, выделенную для объекта, предотвращая утечки памяти.

# core/inc/interfaces/interactable.h

## Общее назначение
Файл `interactable.h` определяет интерфейс для объектов, которые могут быть интерактивными. Он предоставляет функциональность для размещения курсора и управления его перемещением, а также для получения координат и конфигурации курсора, что позволяет объектам взаимодействовать с пользовательским интерфейсом.

## Основные компоненты

### Функции
- ``void (*place_cursor)(const void *self, const Coords, Coords *);``
  - Позволяет разместить курсор на заданных координатах.
  - Вызывает функцию с координатами и базовыми координатами для обновления.

- ``void (*move)(const void *self, Coords *, const Coords);``
  - Перемещает объект на определённое смещение.
  - Используется для обновления позиции объекта, принимая текущее положение и дельту.

- ``Coords (*get_default_coords)(const void *self);``
  - Возвращает координаты по умолчанию для объекта.
  - Это важно для начального размещения или сброса позиции.

- ``void (*custom_draw)(const void *self, const Cursor *, Screen *, const Coords);``
  - Позволяет провести кастомизированное рисование объекта на экране.
  - Используется для отрисовки объекта с учетом его состояния и позиции курсора.

- ``CursorConfig (*get_cursor_config)(const void *self, const Coords);``
  - Получает конфигурацию курсора для указанных координат.
  - Используется для настройки поведения курсора в зависимости от объекта.

### Переменные
- Отсутствуют.

### Макросы
- Отсутствуют.

## Логика работы
Интерфейс `Interactable` предоставляет механизмы для взаимодействия объектов с пользовательским интерфейсом. Основное взаимодействие происходит через функции, которые принимают параметры объекта и координаты. Все функции используют макросы для извлечения интерфейса из объекта, что позволяет централизованно управлять интерактивностью. Интерфейс также предполагает наличие объекта курсора и экрана, на котором будет происходить отрисовка.

## Простой пример использования
```c
Coords cursor_pos = {10, 20};
Coords base_coords;
void *object; // Указатель на объект, реализующий интерфейс Interactable

PLACE_CURSOR(object, cursor_pos, &base_coords);
```
- В этом примере функция `PLACE_CURSOR` размещает курсор на координатах (10, 20) и обновляет базовые координаты. Это демонстрирует, как интерактивные объекты могут управлять позициями курсора в интерфейсе.

# core/inc/interfaces/interfaces.h

## Общее назначение
Файл `interfaces.h` служит основным интерфейсом для объектов в проекте. Он предоставляет возможности и интерфейсы, которые могут быть использованы различными объектами, обеспечивая их функциональность. Этот файл следует включать в реализацию объектов для доступа к интерфейсам и функциям, описанным в других заголовочных файлах.

## Основные компоненты
### Функции
- `#include "object_interfaces.h"`
  - Подключение базовых интерфейсов объектов.
- `#include "drawable.h"`
  - Подключение интерфейса для объектов, которые могут быть нарисованы на экране.
- `#include "interactable.h"`
  - Подключение интерфейса для объектов, которые могут быть интерактивными.
- `#include "dynamic.h"`
  - Подключение интерфейса для объектов, которые могут быть динамически выделены.
- `#include "updatable.h"`
  - Подключение интерфейса для объектов, которые могут обновляться.
- `#include "position_handler.h"`
  - Подключение интерфейса для объектов, которые могут управлять позициями.
- `#include "button_handler.h"`
  - Подключение интерфейса для объектов, которые могут обрабатывать нажатия кнопок.
- `#include "card_handler.h"`
  - Подключение интерфейса для объектов, которые могут работать с картами.
- `#include "core_dependent.h"`
  - Подключение интерфейса для объектов, которые зависят от ядра.

## Логика работы
Файл `interfaces.h` не содержит реализации, а лишь объединяет различные интерфейсы в единую структуру, доступную для других компонентов системы. Это позволяет разработчикам легко использовать различные функциональные возможности, не вникая в детали реализации каждого интерфейса. Компоненты, такие как `drawable`, `interactable`, и другие, предоставляют обширный набор функций, которые могут быть использованы при создании интерактивных и визуально привлекательных объектов.

Применение этого файла приводит к упрощению управления интерфейсами объектов и улучшает читаемость кода за счет централизации.

## Простой пример использования
```c
#include "interfaces.h"

// Пример структуры, использующей интерфейсы
typedef struct MyObject {
    Interactable interactable;
    Drawable drawable;
    Dynamic dynamic;
} MyObject;

// Создание объекта и использование его интерфейсов
MyObject obj;
SET_DRAWABLE_ACTIVE(&obj, true);
```
- В этом примере создается структура `MyObject`, которая использует интерфейсы `Interactable`, `Drawable` и `Dynamic`. С помощью функции `SET_DRAWABLE_ACTIVE` мы можем активировать визуальное отображение объекта. Это демонстрирует возможность использования различных интерфейсов для расширения функциональности объекта.

# core/inc/interfaces/object_interfaces.h

## Общее назначение
Файл `object_interfaces.h` определяет структуру `ObjectInterfaces`, которая предоставляет доступ к интерфейсам и возможностям объектов, которые могут взаимодействовать с различными компонентами. Он включает в себя интерфейсы для обработки карт, взаимодействия, динамического выделения памяти, управления положением и др.

## Основные компоненты
### Функции
- ``ObjectInterfaces *GET_INTERFACES(const void *object)``
  - Позволяет получить указатель на структуру `ObjectInterfaces`, ассоциированную с переданным объектом.
  - Используется для доступа ко всем интерфейсам объекта.

### Переменные
- Нет объявленных переменных.

### Макросы
- Нет объявленных макросов.

## Логика работы
Структура `ObjectInterfaces` содержит флаги возможностей, такие как `can_hold_cards`, `have_buttons`, `is_drawable`, и предоставляет указатели на различные интерфейсы, такие как `CardHandler`, `Interactable`, `Dynamic`, `CoreDependent`, `Drawable`, `ButtonHandler`, `PositionHandler` и `Updateable`. 
Метод `GET_INTERFACES` позволяет безопасно извлекать интерфейсы из объекта, что упрощает использование интерфейсной системы в других модулях проекта.

## Простой пример использования
- `ObjectInterfaces *interfaces = GET_INTERFACES(object);`
- В этом примере, функция `GET_INTERFACES` используется для получения интерфейсов, связанных с данным объектом, что позволяет далее использовать их для вызова методов или проверки возможностей объекта.

# core/inc/interfaces/position_handler.h

## Общее назначение
Файл `position_handler.h` определяет интерфейс для объектов, способных управлять позициями. Он предоставляет возможности для восстановления и сохранения текущих координат, что позволяет эффективно управлять состоянием объектов в пространстве.

## Основные компоненты
### Функции
- ```void restore_pos(void *self, Coords *current_coords)```
  - Описание: Функция восстанавливает позицию объекта, используя текущие координаты.
  - Особенности использования: Необходимо передать указатель на текущие координаты для обновления их значений.

- ```void save_current_pos(void *self, Coords current_coords)```
  - Описание: Функция сохраняет текущие координаты объекта для последующего восстановления.
  - Особенности использования: Сохраняемые координаты будут доступны через метод `restore_pos`.

### Переменные
- ```Coords restore_coords```
  - Описание: Переменная для хранения координат, которые могут быть восстановлены при необходимости.
  
### Макросы
- ```PositionHandler *POSITION_HANDLER(const void *object)```
  - Описание: Макрос для получения указателя на структуру `PositionHandler` из объекта.
  
- ```bool IS_POSITIONABLE(const void *object)```
  - Описание: Проверяет, поддерживает ли объект возможности обработки позиций.

- ```void RESTORE_POSITION(void *object, Coords *coords)```
  - Описание: Восстанавливает позицию объекта на основе текущих координат.

- ```void SAVE_POSITION(void *object, Coords coords)```
  - Описание: Сохраняет текущие координаты объекта.

- ```Coords GET_RESTORE_COORDS(const void *object)```
  - Описание: Получает координаты, которые будут восстановлены.

- ```void SET_RESTORE_COORDS(void *object, Coords coords)```
  - Описание: Устанавливает координаты для восстановления.

## Логика работы
Структура `PositionHandler` управляет состоянием объектов, позволяя им сохранять и восстанавливать свои координаты. Каждый объект, реализующий этот интерфейс, может взаимодействовать с его методами для управления своим положением в пространстве. Например, когда объект перемещается, его текущая позиция может быть сохранена для последующего восстановления. Это взаимодействие позволяет упрощать управление состоянием объектов, поддерживающих координаты.

## Простой пример использования
- Пример: 
```c
Coords current_position = {10, 20};
SAVE_POSITION(object, current_position);
```
- Объяснение примера: В данном примере текущие координаты объекта сохраняются с помощью функции `SAVE_POSITION`. Это позволяет в дальнейшем легко восстановить его позицию при необходимости.

# core/inc/interfaces/updatable.h

## Общее назначение
Файл `updatable.h` определяет интерфейс для объектов, которые могут быть обновлены. Он предоставляет метод обновления и управляет контекстом, необходимым для выполнения обновления. Реализация данного интерфейса позволяет объектам получать обновления в соответствии с определенной логикой работы.

## Основные компоненты
### Функции
- ``Updateable *UPDATEABLE_HANDLER(const void *object)``
  - Возвращает указатель на структуру `Updateable`, ассоциированную с данным объектом.
  - Используется для получения интерфейса обновления объекта.

- ``bool IS_UPDATEABLE(const void *object)``
  - Проверяет, поддерживает ли объект возможность обновления.
  - Упрощает проверку на наличие интерфейса обновления.

- ``void UPDATE(void *object)``
  - Вызывает метод обновления объекта, передавая контекст.
  - Используется для выполнения обновления, когда объект должен измениться.

- ``void SET_UPDATE_CONTEXT(void *object, void *context)``
  - Устанавливает контекст, который будет использоваться при обновлении.
  - Позволяет задавать дополнительные данные для метода обновления.

### Переменные
- `void *context`
  - Контекст, который передается в метод обновления.
  - Позволяет передавать различные данные, необходимые для выполнения обновления.

### Макросы
Нет дополнительных макросов в данном файле.

## Логика работы
Файл `updatable.h` взаимодействует с другими интерфейсами через структуру `ObjectInterfaces`, предоставляя методы для проверки возможности обновления объектов. Главный алгоритм заключается в том, что объект с интерфейсом `Updateable` может быть обновлен с использованием метода `UPDATE`, который, в свою очередь, извлекает контекст и выполняет логику обновления.

## Простой пример использования
- `UPDATE(myObject);`
- В этом примере `myObject` — это указатель на объект, который реализует интерфейс `Updateable`. Вызов функции `UPDATE` инициирует обновление объекта, используя текущий контекст, установленный для него.

