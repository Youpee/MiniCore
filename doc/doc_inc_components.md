# core/inc/components/arena_alloc.h

## Общее назначение
Данный файл содержит определения структур и функций для управления памятью с использованием арены. Арена представляет собой пул памяти, который позволяет эффективно выделять и освобождать блоки памяти. Использование арены помогает минимизировать фрагментацию и улучшить производительность операций выделения и освобождения памяти.

## Основные компоненты

### Функции
- ``Arena *arena_new_dynamic(size_t size);``
  Создает новую арену с динамически выделенной памятью заданного размера.
  
- ``Arena *arena_new_static(void *memory, size_t size);``
  Создает новую арену, используя статически выделенную память, переданную указателем.
  
- ``void arena_reset(Arena *arena);``
  Сбрасывает состояние арены, освобождая все выделенные блоки, и возвращая её к начальному состоянию.
  
- ``void *arena_alloc(Arena *arena, size_t size);``
  Выделяет блок памяти размером `size` из арены.
  
- ``void arena_free_block(Arena *arena, void *data);``
  Освобождает ранее выделенный блок памяти, указанный `data`, внутри арены.

- ``void arena_free(Arena *arena);``
  Освобождает всю память, используемую аренной, и возвращает ресурсы.

- ``void print_arena(Arena *arena);``
  Выводит информацию о состоянии арены, включая занятые и свободные блоки.

### Переменные
(Нет объявлений переменных в данном файле)

### Макросы
- ``#define MIN_BUFFER_SIZE 16``
  Определяет минимальный размер буфера для арены. Используется для обеспечения достаточного размера выделяемых блоков.

## Логика работы
Файл содержит две основные структуры: `Block` и `Arena`. Структура `Block` управляет отдельными блоками памяти и их состоянием (свободно/занято), а структура `Arena` хранит информацию о пуле памяти, включая список всех блоков и указатель на свободные блоки. Функции, такие как `arena_alloc` и `arena_free_block`, обеспечивают выделение и освобождение памяти, опираясь на состояние блоков. Связь с другими модулями может происходить через использование арены для управления памятью в различных компонентах системы. 

## Простой пример использования
- ```c
  Arena *my_arena = arena_new_dynamic(1024);
  void *data = arena_alloc(my_arena, 128);
  arena_free_block(my_arena, data);
  arena_free(my_arena);
  ```

- В этом примере создается новая динамическая арена с размером 1024 байта. Затем выделяется блок памяти размером 128 байт из арены. После использования, выделенный блок освобождается, и в конце освобождаются все ресурсы, связанные с аренной. Это демонстрирует основные функции выделения и освобождения памяти с использованием арены.

# core/inc/components/card.h

## Общее назначение
Файл `card.h` содержит определение базовой структуры `Card`, которая может быть расширена конкретными реализациями для представления карточек с определенными свойствами. Структура предоставляет только координаты, что позволяет использовать её в различных контекстах, где необходима работа с карточками. Файл также включает предопределенные макросы для настройки размеров карточек.

## Основные компоненты
### Функции
Нет функций, определенных в этом файле.

### Переменные
Нет глобальных переменных.

### Макросы
- `#define CARD_HEIGHT 1`  
  Определяет высоту карточки по умолчанию. Значение может быть изменено в других частях кода перед включением этого заголовка.
  
- `#define CARD_WIDTH 1`  
  Определяет ширину карточки по умолчанию. Как и с высотой, это значение также может быть изменено.

### Структуры
- `typedef struct Card`  
  Структура, представляющая карточку, содержащая следующие члены:
  - `Coords coords` - структура, содержащая координаты карточки.

## Логика работы
Структура `Card` является базовой для реализации более сложных карточек. Она включает в себя только координаты, позволяя различным модулям использовать её в визуальных представлениях или играх, где требуется размещение карточек. Взаимодействие с другими модулями может происходить через расширенные структуры, которые используют `Card` в качестве основы и добавляют дополнительные поля или методы. Определенные размеры карточек могут быть изменены при компиляции, что обеспечивает гибкость в настройках.

## Простой пример использования
```c
Card my_card;
my_card.coords.x = 10;
my_card.coords.y = 20;
```
В этом примере создается экземпляр структуры `Card`, и устанавливаются координаты карточки. Это позволяет расположить карточку на заданных координатах, что важно для любой системы, использующей графическое отображение или взаимодействие с пользователем.

# core/inc/components/components.h

## Общее назначение
Файл `components.h` служит для объединения всех компонентов ядра проекта. Он предоставляет необходимые структуры и объявления для работы с различными элементами, такими как аллокация памяти, координаты, контейнеры, экраны, курсоры, карты и карты игральных карточек. Включение этого файла в другие модули позволяет использовать все перечисленные компоненты в одном месте.

## Основные компоненты
- ### Функции
  - Нет явных функций в этом файле, так как он предназначен для включения других заголовочных файлов.
  
- ### Переменные
  - Нет глобальных переменных, определённых в этом файле.

- ### Макросы
  - `#ifndef COMPONENTS_H`
    - Защищает файл от многократного включения.
  - `#define COMPONENTS_H`
    - Определяет флаг, указывающий на то, что файл был включен.
  
## Логика работы
Этот файл использует директивы препроцессора для включения других заголовочных файлов, таких как `arena_alloc.h`, `coords.h`, `container.h`, `screen.h`, `cursor.h`, `map.h` и `card.h`. Все эти компоненты реализуют различные аспекты функциональности проекта, и их объединение в одном заголовочном файле облегчает управление зависимостями и поддерживает более структурированный подход к архитектуре.

## Простой пример использования
```c
#include "components.h"
```
- Объяснение примера: При добавлении этой строки в другой файл, разработчик получает доступ ко всем компонентам, определённым в других включённых заголовках, что позволяет использовать структуры и функции, связанные с управлением памятью, координатами, картами и другими элементами системы.

# core/inc/components/container.h

## Общее назначение
Файл содержит определение структуры `Container`, представляющей универсальный контейнер для хранения и управления данными между объектами. Он предоставляет функции для инициализации контейнера, добавления и извлечения элементов, а также для управления состоянием контейнера. Данный контейнер позволяет отслеживать источник данных, что повышает его гибкость и универсальность.

## Основные компоненты

### Функции
- ``Container *container_init(Arena *arena, int length);``  
  Инициализация контейнера с заданной длиной в указанной арене.  
  Используется для создания нового экземпляра контейнера в управляемой области памяти.

- ``void container_free(Arena *arena, Container *container);``  
  Освобождение ресурсов, занимаемых контейнером.  
  Необходимо вызывать для предотвращения утечек памяти.

- ``void container_add_element(Container *container, void *element);``  
  Добавление элемента в контейнер.  
  Позволяет динамически расширять контейнер, добавляя новые данные.

- ``void container_clear_container(Container *container);``  
  Очистка контейнера, удаление всех элементов.  
  Важно для освобождения ресурсов без уничтожения самого контейнера.

- ``bool container_is_empty(const Container *container);``  
  Проверка на пустоту контейнера.  
  Удобно для проверки состояния контейнера перед выполнением операций извлечения.

- ``void container_set_source(Container *container, void *source);``  
  Установка источника данных для контейнера.  
  Позволяет отслеживать откуда были получены данные, что может быть полезно для логирования или отладки.

- ``void *container_pop_element(Container *container);``  
  Извлечение последнего элемента из контейнера.  
  Используется для реализации стека или очереди в зависимости от порядка добавления элементов.

- ``void *container_get_element(const Container *container, const int index);``  
  Получение элемента по индексу.  
  Позволяет обращаться к элементам контейнера по их позициям.

### Переменные
- `int size;`  
  Общий размер контейнера, максимальное количество элементов.  
  Позволяет контролировать пределы контейнера.

- `int length;`  
  Текущая длина контейнера, количество добавленных элементов.  
  Полезно для определения заполненности контейнера.

- `void *source;`  
  Указатель на источник данных, откуда были получены элементы контейнера.  
  Используется для отслеживания происхождения данных.

- `void **container;`  
  Указатель на массив указателей, хранящий элементы контейнера.  
  Обеспечивает динамическое распределение памяти для хранения данных.

## Логика работы
Контейнер реализует механизмы для управления данными и их источниками в рамках проекта. Он использует арену для распределения памяти, что обеспечивает эффективное управление ресурсами. Взаимодействие между компонентами осуществляется через предоставленные функции, позволяющие манипулировать данными без необходимости в прямом управлении памятью. Связи с другими модулями, такими как `arena_alloc`, обеспечивают совместимость и интеграцию различных компонентов системы.

## Простой пример использования
- ```C
  Arena *arena = arena_new_dynamic(1024);
  Container *container = container_init(arena, 10);
  int element = 5;
  container_add_element(container, &element);
  ```

- В этом примере создается новая динамическая арена объемом 1024 байта, после чего инициализируется контейнер с длиной 10. Затем в контейнер добавляется элемент со значением 5. Этот пример демонстрирует процесс создания контейнера и добавления в него данных, при этом используются функции, описанные ранее.

# core/inc/components/coords.h

## Общее назначение
Файл `coords.h` содержит определение структуры `Coords`, представляющей базовые трехмерные координаты. Эта структура используется для позиционирования объектов в игровом пространстве, что является важной частью многих игровых механизмов и логики. Определение координат в 3D позволяет более точно управлять местоположением объектов.

## Основные компоненты
### Функции
(В этом файле функции не определены.)

### Переменные
(В этом файле переменные не определены.)

### Макросы
(В этом файле макросы не определены.)

## Логика работы
Структура `Coords` инкапсулирует три координаты (x, y, z), которые позволяют позиционировать объекты в трехмерном пространстве. Она может быть использована в других компонентах системы для определения местоположения элементов, таких как карты, персонажи или другие объекты в игре. Связь с другими модулями происходит через использование этой структуры в качестве параметров для функций, которые требуют информации о позициях.

## Простой пример использования
```c
Coords position = {2, 5, 1};
```
В этом примере создается экземпляр структуры `Coords`, который инициализируется значениями для осей x, y и z. Используя этот объект, разработчик может управлять положением объектов в игровом пространстве, обращаясь к их координатам.

# core/inc/components/cursor.h

## Общее назначение
Файл `cursor.h` определяет структуры и функции, связанные с управлением курсором в игровом пространстве. Он содержит векторы перемещения курсора, структуру состояния курсора, а также предустановленные стили и конфигурации курсора. Этот модуль позволяет пользователям взаимодействовать с объектами в игровом мире, обеспечивая удобное управление и отображение курсора.

## Основные компоненты
### Функции
- ```Cursor *init_cursor(Arena *arena, void *start_object, Coords start_coords, Container *cursor_cards);```
  - Функция инициализирует курсор, устанавливая его начальные координаты и объект, на который он указывает.
  - Используется для создания нового курсора с заданным контекстом.

- ```void print_cursor(Cursor *cursor, Screen *screen);```
  - Функция отвечает за отображение текущего состояния курсора на экране.
  - Необходимо убедиться, что курсор и экран корректно инициализированы перед вызовом.

- ```void set_cursor(Cursor *cursor, Coords coords, void *target_subject);```
  - Устанавливает новую позицию курсора и объект, на который он указывает.
  - Позволяет динамически изменять местоположение курсора в игре.

### Переменные
- В файле не объявлено явных переменных.

### Макросы
- ```#define CURSOR_UP    (Coords){.x = 0,  .y = -1}```
  - Определяет вектор перемещения курсора вверх.

- ```#define CURSOR_DOWN  (Coords){.x = 0,  .y = 1}```
  - Определяет вектор перемещения курсора вниз.

- ```#define CURSOR_LEFT  (Coords){.x = -1, .y = 0}```
  - Определяет вектор перемещения курсора влево.

- ```#define CURSOR_RIGHT (Coords){.x = 1,  .y = 0}```
  - Определяет вектор перемещения курсора вправо.

- ```#define CURSOR_STAY  (Coords){.x = 0,  .y = 0}```
  - Определяет вектор, при котором курсор остается на месте.

## Логика работы
Файл управляет состоянием курсора, включая его позицию и взаимодействие с объектами в игровом пространстве. Определенные векторы перемещения курсора позволяют легко изменять его местоположение, что важно для реализации интуитивно понятного управления. Структура `CursorConfig` настраивает визуальное представление курсора, позволяя разработчикам выбирать стили отображения в зависимости от контекста использования. Взаимодействие с другими модулями, такими как `Container` и `Screen`, позволяет управлять состоянием курсора и обновлять его визуализацию в реальном времени.

## Простой пример использования
- ```Cursor *my_cursor = init_cursor(my_arena, my_object, (Coords){.x = 0, .y = 0}, my_container);```
- В этом примере создается новый курсор, который инициализируется в области памяти `my_arena`, с начальным объектом `my_object`, стартовыми координатами и контейнером `my_container` для выбранных карт. Это демонстрирует, как курсор может быть легко создан и настроен для использования в различных контекстах в игре.

# core/inc/components/map.h

## Общее назначение
Файл `map.h` содержит определения структур и функций, связанных с управлением картами в игре. Он описывает объекты и слои карты, а также предоставляет функциональность для работы с ними, включая инициализацию, перемещение и доступ к объектам на карте. Основной акцент сделан на хранение и манипуляцию данными о расположении объектов на различных слоях.

## Основные компоненты
### Функции
- ``Map *init_map(Arena *arena, int layers, Coords global_coords);``
  Инициализирует новую карту с указанным количеством слоев и глобальными координатами.
  
- ``void map_set_layer(Map *map, MapLayer *map_layer, int layer);``
  Устанавливает указанный слой карты в конкретную позицию.

- ``void map_move(Map *map, Coords move);``
  Перемещает глобальные координаты карты на заданное смещение.

- ``void map_move_layer(Map *map, int layer);``
  Перемещает указанный слой карты.

- ``MapLayer *map_get_layer(Map *map, int layer);``
  Возвращает слой карты по указанному индексу.

- ``MapLayer *map_get_current_layer(Map *map);``
  Возвращает текущий слой карты.

- ``MapObject map_get_current_object(Map *map);``
  Получает текущий объект на карте.

- ``MapObject map_get_object(Map *map, Coords coords);``
  Получает объект на карте по заданным координатам.

### Переменные
- `int layers_count;`
  Хранит количество слоев на карте.

- `MapLayer **layers;`
  Указывает на массив слоев карты.

- `Coords global_coords;`
  Хранит глобальные координаты карты.

### Макросы
- Нет макросов в этом файле.

## Логика работы
Файл предоставляет структуры, которые организуют данные о карте и её слоях. `MapLayer` хранит информацию о каждом слое, включая размеры, объекты и функции для подготовки экрана и обработки циклов на слое. Структура `Map` агрегирует слои и управляет глобальной позицией. Взаимодействие с другими модулями происходит через структуры `Coords` и `MapObject`, которые определяют местоположение объектов в игровом пространстве.

## Простой пример использования
```c
Arena *arena = arena_new_dynamic(1024);
Coords initial_coords = {.x = 0, .y = 0, .z = 0};
Map *game_map = init_map(arena, 3, initial_coords);
```
В этом примере создается новая динамическая арена, затем инициализируется карта с тремя слоями и начальными координатами. Это позволяет начать работу с картой и управлять её слоями и объектами.

# core/inc/components/arena_alloc.h

## Общее назначение
Данный файл содержит определения структур и функций для управления памятью с использованием аллокатора арен. Он включает в себя структуры для блоков памяти и самой арены, а также функции для создания, освобождения и работы с этими объектами. Аллокатор арен обеспечивает эффективное распределение памяти и управление состоянием блоков.

## Основные компоненты
### Функции
- ``Arena *arena_new_dynamic(size_t size);``
  Создает новую арену с динамическим выделением памяти указанного размера.
  
- ``Arena *arena_new_static(void *memory, size_t size);``
  Создает новую арену с статическим выделением памяти, используя предоставленный указатель.

- ``void arena_reset(Arena *arena);``
  Сбрасывает арену к начальному состоянию, освобождая все выделенные блоки.

- ``void *arena_alloc(Arena *arena, size_t size);``
  Выделяет блок памяти заданного размера из арены.

- ``void arena_free_block(Arena *arena, void *data);``
  Освобождает выделенный блок памяти, который был ранее получен через `arena_alloc`.

- ``void arena_free(Arena *arena);``
  Освобождает все ресурсы, связанные с ареной.

- ``void print_arena(Arena *arena);``
  Выводит информацию о состоянии арены и ее блоках.

### Переменные
(переменные отсутствуют)

### Макросы
- ``#define MIN_BUFFER_SIZE 16``
  Определяет минимальный размер буфера для арены по умолчанию.

## Логика работы
Функции манипулируют объектами арены, управляя блоками памяти. Аллокатор использует структуры `Block` и `Arena` для отслеживания состояния выделенных и свободных блоков. Связи с другими модулями проекта (например, `components.h`) обеспечивают интеграцию с другими компонентами системы, такими как динамическое выделение памяти и управление ресурсами. Основной алгоритм включает выделение памяти из арены и управление состояниями блоков (свободный/занятый).

## Простой пример использования
```c
Arena *myArena = arena_new_dynamic(1024);
void *block = arena_alloc(myArena, 128);
arena_free_block(myArena, block);
arena_free(myArena);
```
В этом примере создается новая арена на 1024 байта, затем выделяется блок размером 128 байт. После использования блок освобождается, а сама арена очищается.

